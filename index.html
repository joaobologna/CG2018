<html>
	<head>
		<title>Projeto CG - Fase 03</title>
		<style>
			body { margin: 0; overflow: 0; }
			canvas { width: 100%; height: 100%; };
		</style>
	</head>
	<body>
		<canvas id="myCanvas"></canvas>
		<script src="js/three.js"></script>
		<script src="js/THREEx.KeyboardState.js"></script>
		<script src="js/OBJLoader.js"></script>
		
		<script id="vertexShader" type="x-shader/x-vertex">
		  varying vec3 vNormal;
		  varying vec3 vViewPosition;
		  uniform float timeDelta;
		  void main() {
			vec3 center = vec3(0.0, 0.0, 0.0);
			vec3 p = position;
			float distance = length(center - p);
			p += sin(distance + timeDelta/1000.0)*0.5;
			vec4 modelViewPosition = modelViewMatrix * vec4(p, 1.0);
			vViewPosition = -modelViewPosition.xyz;
			gl_Position = projectionMatrix * modelViewPosition;
			vNormal = normalMatrix * normal;
		  }
		</script>
		
		<script>
			var keyboard = new THREEx.KeyboardState();
			var sideCameraEnabled = true;
			var cat, rat, knife, cheese;			

			var curveCat = new THREE.CatmullRomCurve3([
				new THREE.Vector3( 0, 0, -5 ),
				new THREE.Vector3( -5, 2, 5 ),
				new THREE.Vector3( 15, 0, 0 )
			] );
			var curveRat = new THREE.CatmullRomCurve3([
				new THREE.Vector3( -5, 5, 5 ),
				new THREE.Vector3( 7, 0, 0 ),
				new THREE.Vector3( -10, 1, 10 ),
			] );
			curveRat.closed = curveCat.closed = true; // fecha os caminho
			var geometryRat = new THREE.Geometry();
			var geometryCat = new THREE.Geometry();
			geometryRat.vertices = curveRat.getPoints(100);
			geometryCat.vertices = curveCat.getPoints( 200 );
			var materialRat = new THREE.LineBasicMaterial( { /*color : 0xa9c41e*/ transparent: true, opacity: 0 } );
			var materialCat = new THREE.LineBasicMaterial( { /*color : 0x11c22e*/ transparent: true, opacity: 0 } );
			pathAlongCurveRat = new THREE.Line( geometryRat, materialRat );
			pathAlongCurveCat = new THREE.Line( geometryCat, materialCat );
			var t = 0;

			init();		

			function init() {
				// Renderer
				renderer = create_renderer();
				
				// Camera com visão superior
				upCamera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
				upCamera.position.set(5, 30, -10);
				upCamera.rotation.x = -90 * Math.PI / 180;

				// Camera com visão lateral
				sideCamera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
				sideCamera.position.set(5, 0.6, 15);
			
				// Cena
				scene = new THREE.Scene();
				scene.add(pathAlongCurveRat);
				scene.add(pathAlongCurveCat);
				
				// Iluminacao
				var light = new THREE.PointLight( 0xa5ccff, 1 );
				light.position.set(300,300,0);
				scene.add( light );

				var uniforms = ({
					timeDelta : {type: 'f', value: 0},
					emissive : {type: 'c', value: new THREE.Color(0x5e807f)},
					specular : {type: 'c', value: new THREE.Color(0xe09278)}
				});
				var phongShader = THREE.ShaderLib.phong;
				
				var mUniforms = THREE.UniformsUtils.merge([phongShader.uniforms, uniforms]);

				load_obj2('obj/cat.obj', [10, 4, 4], [-4, 0, 0], [0, 1.6, 0]);
				load_obj2('obj/rat.obj', [0.8, 1, 1], [4, 0, 0], [0, 1.6, 0]);
				// load_obj2('obj/knife.obj', [0.007, 0.017, 0.007], [10, 2, 2], [5, 0, 0]);
				// load_obj2('obj/cheese.obj', [0.5, 0.5, 0.5], [10, 0, -2], [0, 0 ,0]);

				// load_obj('json/cat.json', [10, 4, 4], [-4, 0, 0], [0, 1.6, 0]);
				// load_obj('json/rat.js', [0.8, 1, 1], [4, 0, 0], [0, 1.6, 0]);
				load_obj('json/knife.js', [0.007, 0.007, 0.007], [10, 2, 2], [10, 0, 0]);
				load_obj('json/cheese.js', [0.2, 0.2, 0.2], [10, 0, -2], [0, 0 ,0]);

				function create_renderer() {
					var myCanvas = document.getElementById('myCanvas');
			
					renderer = new THREE.WebGLRenderer({
					  canvas: myCanvas, 
					  antialias: true
					});
			
					// Renderer
					renderer.setClearColor(0x000000);
					renderer.setPixelRatio(window.devicePixelRatio);
					renderer.setSize(window.innerWidth, window.innerHeight);
					
					return renderer;				
				}

				function load_obj2(path, dimensions, position, rotation) {
				 var mesh2Material = new THREE.ShaderMaterial ({
								uniforms : mUniforms,
								vertexShader: document.getElementById( 'vertexShader' ).textContent,
								fragmentShader: phongShader.fragmentShader,
								lights: true,
								side : THREE.DoubleSide
							});
				  var mesh2;
				  var loader = new THREE.OBJLoader();

				  loader.load(path, function ( object ) {
				    object.traverse( function ( child ) {
				      if ( child instanceof THREE.Mesh ) {
				        console.log(child.geometry)
				        var geo1 = child.geometry;
				        mesh2 = new THREE.Mesh(geo1, mesh2Material);

								mesh2.scale.set(dimensions[0], dimensions[1], dimensions[2]); // alteração do tamanho do objeto
								mesh2.position.x = position[0];
								mesh2.position.y = position[1];
								mesh2.position.z = position[2];	
								mesh2.rotation.x = rotation[0];
								mesh2.rotation.y = rotation[1];
								mesh2.rotation.z = rotation[2];
								scene.position.z = -10;

								switch(path){
									case 'obj/cat.obj':
										cat = mesh2;
									break;
									case 'obj/rat.obj':
										rat = mesh2;
									break;
									case 'obj/knife.obj':
										knife = mesh2;
									break;
									case 'obj/cheese.obj':
										cheese = mesh2;
									break;
								}
				      }
				    });
				  })
				}

				function load_obj(path, dimensions, position, rotation) {
					loader = new THREE.JSONLoader();
					loader.load(path, handle_load);
			
					function handle_load(geometry, materials) {
						materials = new THREE.MeshNormalMaterial();
						mesh = new THREE.Mesh(geometry, materials);
						mesh.scale.set(dimensions[0], dimensions[1], dimensions[2]); // alteração do tamanho do objeto
						mesh.position.x = position[0];
						mesh.position.y = position[1];
						mesh.position.z = position[2];	
						mesh.rotation.x = rotation[0];
						mesh.rotation.y = rotation[1];
						mesh.rotation.z = rotation[2];
						scene.position.z = -10;
						//scene.add(mesh);

						switch(path){
							case 'json/cat.json':
								cat = mesh;
							break;
							case 'json/rat.js':
								rat = mesh;
							break;
							case 'json/knife.js':
								knife = mesh;
							break;
							case 'json/cheese.js':
								cheese = mesh;
							break;
						}
					}
				}

				preAnimate();
			}
			
			// adiciona os objetos na cena apenas quando todos forem carregados
			function preAnimate(){
					setTimeout(function () {
						if(cat == null || rat == null || knife  == null || cheese  == null){
							preAnimate();
						}
						else{
							scene.add(cat);
							scene.add(rat);
							scene.add(knife);
							scene.add(cheese);
							animate();
						}
					}, 1); // timeout (em ms), gasto quantas vezes forem necessárias, para que os objetos sejam carregados antes de serem utilizados
			}


			var startTime = Date.now();
			var timeDelta = 0;
			
			function animate() {
				timeDelta = Date.now() - startTime;
				requestAnimationFrame(animate);
				// catMesh.material.uniforms.timeDelta.value = timeDelta;

				if (keyboard.pressed("1"))
					sideCameraEnabled = true;
				if (keyboard.pressed("2"))
					sideCameraEnabled = false;

				render();	
			}

			function render() {
				renderer.clear();

				t += 0.001;
				var posRat =  curveRat.getPoint(t);
				rat.position.set(posRat.x, posRat.y, posRat.z);
				var posCat =  curveCat.getPoint(t);
				cat.position.set(posCat.x, posCat.y, posCat.z);

				if (sideCameraEnabled)
					renderer.render(scene, sideCamera);
				else
		  			renderer.render(scene, upCamera); 

			}
		</script>
	</body>
</html>
