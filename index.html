<html>
	<head>
		<title>Projeto CG - Fase 03</title>
		<style>
			body { margin: 0; overflow: 0; }
			canvas { width: 100%; height: 100%; };
		</style>
	</head>
	<body>
		<canvas id="myCanvas"></canvas>
		<script src="js/three.js"></script>
		<script src="js/THREEx.KeyboardState.js"></script>
		<script src="js/OBJLoader.js"></script>
		<script src="js/MTLLoader.js"></script>
		
		<!-- Fonte utilizada para o Phong: https://github.com/sneha-belkhale/threejs-shader-demo -->
		<script id="vertexShader" src="js/phong.js" type="x-shader/x-vertex">
		  varying vec3 vNormal;
		  varying vec3 vViewPosition;
		  uniform float timeDelta;
		  void main() {
			vec3 center = vec3(0.0, 0.0, 0.0);
			vec3 p = position;
			float distance = length(center - p);
			p += sin(distance + timeDelta/1000.0)*0.5;
			vec4 modelViewPosition = modelViewMatrix * vec4(p, 1.0);
			vViewPosition = -modelViewPosition.xyz;
			gl_Position = projectionMatrix * modelViewPosition;
			vNormal = normalMatrix * normal;
		  }
		</script>
		
		<script>
			var keyboard = new THREEx.KeyboardState();
			var sideCameraEnabled = true;
			var cat, rat;			

			var curveCat = new THREE.CatmullRomCurve3([
				new THREE.Vector3( 0, 0, -5 ),
				new THREE.Vector3( -5, 2, 5 ),
				new THREE.Vector3( 15, 0, 0 )
			] );
			var curveRat = new THREE.CatmullRomCurve3([
				new THREE.Vector3( -5, 5, 5 ),
				new THREE.Vector3( 7, 0, 0 ),
				new THREE.Vector3( -10, 1, 10 ),
			] );
			curveRat.closed = curveCat.closed = true; // fecha os caminho
			var geometryRat = new THREE.Geometry();
			var geometryCat = new THREE.Geometry();
			geometryRat.vertices = curveRat.getPoints(100);
			geometryCat.vertices = curveCat.getPoints( 200 );
			var materialRat = new THREE.LineBasicMaterial( { /*color : 0xa9c41e*/ transparent: true, opacity: 0 } );
			var materialCat = new THREE.LineBasicMaterial( { /*color : 0x11c22e*/ transparent: true, opacity: 0 } );
			pathAlongCurveRat = new THREE.Line( geometryRat, materialRat );
			pathAlongCurveCat = new THREE.Line( geometryCat, materialCat );
			var t = 0;

			init();		

			function init() {
				// Renderer
				renderer = create_renderer();
				
				// Camera com visão superior
				upCamera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
				upCamera.position.set(5, 30, -30);
				upCamera.rotation.x = -90 * Math.PI / 180;

				// Camera com visão lateral
				sideCamera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
				sideCamera.position.set(5, 0.6, 15);
			
				// Cena
				scene = new THREE.Scene();
				scene.add(pathAlongCurveRat);
				scene.add(pathAlongCurveCat);
				
				// Iluminacao
				mount_shader(scene);

				// Adicionando chão
				mount_ground(scene);


				var uniforms = ({
					timeDelta : {type: 'f', value: 0},
					emissive : {type: 'c', value: new THREE.Color(0x5e807f)},
					specular : {type: 'c', value: new THREE.Color(0xe09278)}
				});
				var phongShader = THREE.ShaderLib.phong;
				
				var mUniforms = THREE.UniformsUtils.merge([phongShader.uniforms, uniforms]);

				render_obj(scene, 'cat', { x: -20, y: -13, z: -20}, {x: 10, y:10, z: 10}, {x: 0, y: 1.6, z: 0});
				render_obj(scene, 'rat', { x: 10, y: -13, z: -20}, {x: 1, y: 1, z: 1}, {x: 0, y: 1.6, z: 0});
				render_obj(scene, 'cheese', { x: 20, y: -13, z: -20}, {x: 0.5, y: 0.5, z: 0.5}, {x: 0, y: 1.6, z: 0});
				render_obj(scene, 'knife', { x: 21, y: -7, z: -17}, {x: 0.015, y: 0.015, z: 0.015}, {x: 10, y: 0, z: 0});
				load_obj2('obj/cat.obj', [0.8, 1, 1], [4, 0, 0], [0, 1.6, 0]);
				load_obj2('obj/rat.obj', [0.8, 1, 1], [4, 0, 0], [0, 1.6, 0]);

				function create_renderer() {
					var myCanvas = document.getElementById('myCanvas');
			
					renderer = new THREE.WebGLRenderer({
					  canvas: myCanvas, 
					  antialias: true
					});
			
					// Renderer
					renderer.setClearColor(0x000000);
					renderer.setPixelRatio(window.devicePixelRatio);
					renderer.setSize(window.innerWidth, window.innerHeight);
					
					return renderer;				
				}

				function render_obj(scene, obj, position, dimensions, rotation) {
					new THREE.OBJLoader()
						.load('assets/' + obj + '/' + obj + '.obj', function (object) {
			        		object.traverse(function (child) {
			            		if (child instanceof THREE.Mesh) {
			            			var texture = new THREE.TextureLoader().load('assets/' + obj + '/' + obj + '.png');
    				                child.material.map = texture;
					                child.castShadow = true;
			        		        child.receiveShadow = true;
			            		}

					        object.position.x = position.x;
					        object.position.y = position.y;
					        object.position.z = position.z;
					        object.rotation.x = rotation.x;
					        object.rotation.y = rotation.y;
					        object.rotation.z = rotation.z;
					        object.scale.set(dimensions.x, dimensions.y, dimensions.z); 
					        scene.add( object );
			        		})
			        	});
				}

				function load_obj2(path, dimensions, position, rotation) {
				 var mesh2Material = new THREE.ShaderMaterial ({
								uniforms : mUniforms,
								vertexShader: document.getElementById( 'vertexShader' ).textContent,
								fragmentShader: phongShader.fragmentShader,
								lights: true,
								side : THREE.DoubleSide
							});
				  var mesh2;
				  var loader = new THREE.OBJLoader();

				  loader.load(path, function ( object ) {
				    object.traverse( function ( child ) {
				      if ( child instanceof THREE.Mesh ) {
				        console.log(child.geometry)
				        var geo1 = child.geometry;
				        mesh2 = new THREE.Mesh(geo1, mesh2Material);

								mesh2.scale.set(dimensions[0], dimensions[1], dimensions[2]); // alteração do tamanho do objeto
								mesh2.position.x = position[0];
								mesh2.position.y = position[1];
								mesh2.position.z = position[2];	
								mesh2.rotation.x = rotation[0];
								mesh2.rotation.y = rotation[1];
								mesh2.rotation.z = rotation[2];
								scene.position.z = -10;

								switch(path){
									case 'obj/cat.obj':
										cat = mesh2;
									break;
									case 'obj/rat.obj':
										rat = mesh2;
									break;
									case 'obj/knife.obj':
										knife = mesh2;
									break;
									case 'obj/cheese.obj':
										cheese = mesh2;
									break;
								}
				      }
				    });
				  })
				}

				function mount_shader(scene) {
					var light = new THREE.PointLight(0xa5ccff, 1);
					light.position.set(300,300,0);
					scene.add(light);
					scene.add(new THREE.AmbientLight(0x222222));
				}

				function mount_ground(scene) {
					var textureLoader = new THREE.TextureLoader();
				    var texture = textureLoader.load("texture/grass.png");
				    var material = new THREE.MeshLambertMaterial({ map: texture });
				    texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
				    texture.repeat.set(256, 256);
				    var geometry = new THREE.PlaneGeometry(1000, 1000); 
				    var ground = new THREE.Mesh(geometry, material); 
				    ground.position.y = -14.1;
				    ground.rotation.x = -Math.PI/2;
				    ground.receiveShadow = true;
				    ground.castShadow = true;
				    scene.add(ground);
				}

				function load_obj(path, dimensions, position, rotation) {
					loader = new THREE.JSONLoader();
					loader.load(path, handle_load);
			
					function handle_load(geometry, materials) {
						materials = new THREE.MeshNormalMaterial();
						mesh = new THREE.Mesh(geometry, materials);
						mesh.scale.set(dimensions[0], dimensions[1], dimensions[2]); // alteração do tamanho do objeto
						mesh.position.x = position[0];
						mesh.position.y = position[1];
						mesh.position.z = position[2];	
						mesh.rotation.x = rotation[0];
						mesh.rotation.y = rotation[1];
						mesh.rotation.z = rotation[2];
						scene.position.z = -10;
						//scene.add(mesh);

						switch(path){
							case 'json/cat.json':
								cat = mesh;
							break;
							case 'json/rat.js':
								rat = mesh;
							break;
							case 'json/knife.js':
								knife = mesh;
							break;
							case 'json/cheese.js':
								cheese = mesh;
							break;
						}
					}
				}

				preAnimate();
			}
			
			// adiciona os objetos na cena apenas quando todos forem carregados
			function preAnimate(){
					setTimeout(function () {
						if(cat == null || rat == null){
							preAnimate();
						}
						else{
							scene.add(cat);
							scene.add(rat);
							animate();
						}
					}, 1); // timeout (em ms), gasto quantas vezes forem necessárias, para que os objetos sejam carregados antes de serem utilizados
			}


			var startTime = Date.now();
			var timeDelta = 0;
			
			function animate() {
				timeDelta = Date.now() - startTime;
				requestAnimationFrame(animate);
				// catMesh.material.uniforms.timeDelta.value = timeDelta;

				if (keyboard.pressed("1"))
					sideCameraEnabled = true;
				if (keyboard.pressed("2"))
					sideCameraEnabled = false;

				render();	
			}

			function render() {
				renderer.clear();

				t += 0.001;
				var posRat =  curveRat.getPoint(t);
				rat.position.set(posRat.x, posRat.y, posRat.z);
				var posCat =  curveCat.getPoint(t);
				cat.position.set(posCat.x, posCat.y, posCat.z);

				if (sideCameraEnabled)
					renderer.render(scene, sideCamera);
				else
		  			renderer.render(scene, upCamera); 

			}
		</script>
	</body>
</html>
